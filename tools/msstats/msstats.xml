<tool id="msstats" name="MSstats" version="@VERSION@.0" python_template_version="3.5">
    <description>statistical relative protein significance analysis in DDA, SRM and DIA Mass Spectrometry</description>
    <macros>
        <token name="@VERSION@">3.20.0</token>
    </macros>
    <requirements>
        <requirement type="package" version="@VERSION@">bioconductor-msstats</requirement>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
        cat $msstats_script > '$r_script';
        Rscript $msstats_script
        && cat msstats.log > $log
        && ls -ltr 
    ]]></command>
    <configfiles>
        <configfile name="msstats_script"><![CDATA[
library('MSstats', warn.conflicts = F, quietly = T, verbose = F)

#if $input.input_src == 'MSstats'

  #if $input.msstats_input.is_of_type('csv')
raw <- read.csv("$input.msstats_input")
  #else
raw <- read.table("$input.msstats_input", sep="\t", header=TRUE)
  #end if

#elif $input.input_src == 'MaxQuant'
\# Read in MaxQuant files
input <- read.table("$input.evidence", sep="\t", header=TRUE)

proteinGroups <- read.table("$input.proteinGroups", sep="\t", header=TRUE)

\# Read in annotation including condition and biological replicates per run.
\# Users should make this annotation file. It is not the output from MaxQuant.
  #if $input.annotation.is_of_type('csv')
annot <- read.csv("$input.annotation", header=TRUE)
  #else
annot <- read.table("$input.annotation", sep="\t", header=TRUE)
  #end if

raw <- MaxQtoMSstatsFormat(evidence=input, 
                           annotation=annot, 
                           proteinGroups=proteinGroups,
                           useUniquePeptide=$input.input_options.useUniquePeptide, 
                           summaryforMultipleRows=$input.input_options.summaryforMultipleRows, 
                           fewMeasurements=$input.input_options.fewMeasurements, 
                           removeMpeptides=$input.input_options.removeMpeptides,
                           removeOxidationMpeptides=$input.input_options.removeOxidationMpeptides,
                           removeProtein_with1Peptide=$input.input_options.removeProtein_with1Peptide)

#elif $input.input_src == 'OpenMS'

  #if $input.evidence.is_of_type('csv')
input <- read.csv("$input.evidence", header=TRUE)
  #else
input <- read.table("$input.evidence", sep="\t", header=TRUE)
  #end if
  #if $input.annotation.is_of_type('csv')
annot <- read.csv("$input.annotation", header=TRUE)
  #else
annot <- read.table("$input.annotation", sep="\t", header=TRUE)
  #end if

raw <- OpenMStoMSstatsFormat(input,
                             annotation=annot,
                             useUniquePeptide=$input.input_options.useUniquePeptide, 
                             summaryforMultipleRows=$input.input_options.summaryforMultipleRows, 
                             fewMeasurements=$input.input_options.fewMeasurements, 
                             removeProtein_with1Peptide=$input.input_options.removeProtein_with1Peptide)

#elif $input.input_src == 'OpenSWATH'

  #if $input.evidence.is_of_type('csv')
input <- read.csv("$input.evidence", header=TRUE)
  #else
input <- read.table("$input.evidence", sep="\t", header=TRUE)
  #end if
  #if $input.annotation.is_of_type('csv')
annot <- read.csv("$input.annotation", header=TRUE)
  #else
annot <- read.table("$input.annotation", sep="\t", header=TRUE)
  #end if

raw <- OpenSWATHtoMSstatsFormat(input,
                                annotation=annot,
                                filter_with_mscore=$input.input_options.filter_with_mscore,
                                mscore_cutoff=$input.input_options.mscore_cutoff,
                                useUniquePeptide=$input.input_options.useUniquePeptide,
                                fewMeasurements="$input.input_options.fewMeasurements",
                                removeProtein_with1Feature=$input.input_options.removeProtein_with1Feature,
                                summaryforMultipleRows="$input.input_options.summaryforMultipleRows")

#elif $input.input_src == 'vignette'
raw <- $input.vignette_data
#end if

goldstandard.proposed <- dataProcess(raw,
                          logTrans=$dp_options.logTrans,
                          normalization="$dp_options.norm.normalization",
                          #if $dp_options.norm.normalization == 'globalStandards'
                          nameStandards=c($dp_options.norm.nameStandards),
                          #end if
                          ## address=$dp_options.address,
                          fillIncompleteRows=$dp_options.fillIncompleteRows,
                          featureSubset="$dp_options.features.featureSubset",
                          #if $dp_options.features.featureSubset == 'topN'
                          n_top_feature=$dp_options.features.n_top_feature,
                          #end if
                          #if $dp_options.features.featureSubset == 'highQuality'
                          remove_uninformative_feature_outlier=$dp_options.features.remove_uninformative_feature_outlier,
                          #end if
                          summaryMethod="$dp_options.summarize.summaryMethod",
                          #if $dp_options.summarize.summaryMethod == 'TMP'
                          MBimpute=$dp_options.summarize.MBimpute,
                          remove50missing=$dp_options.summarize.remove50missing,
                          #end if
                          #if $dp_options.summarize.summaryMethod == 'linear'
                          equalFeatureVar=$dp_options.summarize.equalFeatureVar,
                          #end if
                          #if $dp_options.censoredInt == 'NULL'
                          censoredInt=NULL,
                          #else
                          censoredInt="$dp_options.censoredInt",
                          #end if
                          cutoffCensored="$dp_options.cutoffCensored",
                          maxQuantileforCensored=$dp_options.maxQuantileforCensored,
                          clusters=NULL)
  
write.table(goldstandard.proposed\$ProcessedData, "ProcessedData.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
write.table(goldstandard.proposed\$RunlevelData, "RunlevelData.tsv", sep = "\t", quote = F, row.names = F, dec = ".")


dataProcessPlots(data = goldstandard.proposed, type="QCplot", ylimUp=35,
                 width=5, height=5, address="MSStats_only_")

dataProcessPlots(data = goldstandard.proposed, type="Profileplot",  ylimUp=35, featureName="NA", width=5, height=5, address="MSStats_only_")

dataProcessPlots(data = goldstandard.proposed, type="Conditionplot", width=5, height=5, address="MSStats_only_")

#*

#### Comparison of different groups
levels(goldstandard.proposed$ProcessedData$GROUP_ORIGINAL)

comparison1 <- matrix(c(1,-1,0,0,0),nrow=1)
comparison2 <- matrix(c(1,0,-1,0,0),nrow=1)
comparison3 <- matrix(c(0,-1,1,0,0),nrow=1)
comparison4 <- matrix(c(0,0,0,-1,1),nrow=1)


comparison <- rbind(comparison1,comparison2,comparison3,comparison4)

row.names(comparison) <- c("early-late", "early-mid","mid-late", "PC-NPT")


DIA_MSStats_comparisons = groupComparison(contrast.matrix = comparison, data = goldstandard.proposed)

write.table(DIA_MSStats_comparisons[["ComparisonResult"]], "Comparison_Results_MSStats_only.txt", sep = "\t", quote = F, row.names = F, dec = ".")


# normal quantile-quantile plots
modelBasedQCPlots(data=DIA_MSStats_comparisons, type="QQPlots",width=5, height=5, address="MSStats_only_")

# residual plots

modelBasedQCPlots(data=DIA_MSStats_comparisons, type="ResidualPlots",width=5, height=5, address="MSStats_only_")



groupComparisonPlots(data = DIA_MSStats_comparisons$ComparisonResult, type = 'VolcanoPlot',
                     width=5, height=5, text.size = 2, x.axis.size = 5, y.axis.size = 5, legend.size = 6, dot.size = 1.0 ,ProteinName = FALSE,  address="MSStats_only_")


groupComparisonPlots(data = DIA_MSStats_comparisons$ComparisonResult, type ='Heatmap')

groupComparisonPlots(data=DDIA_MSStats_comparisons$ComparisonResult, type="ComparisonPlot",width=5, height=5, address="MSStats_only_")
*#
        ]]></configfile>
    </configfiles>
    <inputs>
        <conditional name="input">
            <param name="input_src" type="select" label="input source">
                <option value="MSstats">MStats 10 column format</option>
                <option value="MaxQuant">MaxQuant</option>
                <option value="OpenMS">OpenMS</option>
                <option value="OpenSWATH">OpenSWATH</option>
                <option value="vignette">MSstats Vignette</option>
            </param>
            <when value="MSstats">
                <param name="msstats_input" type="data" format="tabular,csv" label="MSstats 10-column input"/>.
            </when>
            <when value="MaxQuant">
                <param name="evidence" type="data" format="tabular,csv" label="evidence.txt - feature-level data"/>.
                <param name="annotation" type="data" format="tabular,csv" label="annotation.txt data which includes Raw.file, Condition, BioReplicate, Run, IsotopeLabelType information"/>
                <param name="proteinGroups" type="data" format="tabular,csv" label="proteinGroups.txt" help="It needs to matching protein group ID. If proteinGroups=NULL, use 'Proteins' column in 'evidence.txt'"/>
                <param name="proteinID" type="select" label="Select Protein ID in proteinGroups.txt">
                    <option value="Proteins">Proteins</option>
                    <option value="proteinGroups">proteinGroups</option>
                </param>
                <section name="input_options" title="MaxQtoMSstatsFormat Options" expanded="false">
                    <param name="useUniquePeptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="remove peptides that are assigned for more than one proteins" help="We assume to use unique peptide for each protein"/>
                    <param name="summaryforMultipleRows" type="select" label="Summary for MultipleRows" help="summaryforMultipleRows - when there are multiple measurements for certain feature and certain run, use highest or sum of all">
                        <option value="max" selected="true">max</option>
                        <option value="sum">sum</option>
                    </param>
                    <param name="fewMeasurements" type="select" label="Remove the features that have 1 or 2 measurements across runs" help="(fewMeasurements)">
                        <option value="remove" selected="true">remove</option>
                        <option value="keep">keep</option>
                    </param>

                    <param name="removeMpeptides" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove the peptides including 'M' sequence"/>
                    <param name="removeOxidationMpeptides" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove the peptides including Oxidized 'M' sequence"/>
                    <param name="removeProtein_with1Peptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove the proteins which have only 1 peptide and charge"/>
                </section>

            </when>
            <when value="OpenMS">
                <param name="evidence" type="data" format="tabular,csv" label="OpenSWATH_input"/>.
                <param name="annotation" type="data" format="tabular,csv" label="OpenSWATH_annotation"/>
                <section name="input_options" title="MaxQtoMSstatsFormat Options" expanded="false">
                    <param name="useUniquePeptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="remove peptides that are assigned for more than one proteins" help="We assume to use unique peptide for each protein"/>
                    <param name="summaryforMultipleRows" type="select" label="Summary for MultipleRows" help="summaryforMultipleRows - when there are multiple measurements for certain feature and certain run, use highest or sum of all">
                        <option value="max" selected="true">max</option>
                        <option value="sum">sum</option>
                    </param>
                    <param name="fewMeasurements" type="select" label="Remove the features that have 1 or 2 measurements across runs" help="(fewMeasurements)">
                        <option value="remove" selected="true">remove</option>
                        <option value="keep">keep</option>
                    </param>
                    <param name="removeProtein_with1Peptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove the proteins which have only 1 peptide and charge"/>
                </section>
            </when>
            <when value="OpenSWATH">
                <param name="evidence" type="data" format="tabular,csv" label="OpenSWATH_input"/>.
                <param name="annotation" type="data" format="tabular,csv" label="OpenSWATH_annotation"/>
                <section name="input_options" title="MaxQtoMSstatsFormat Options" expanded="false">
                    <param name="filter_with_mscore" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove the peptides including 'M' sequence"/>
                    <param name="mscore_cutoff" type="float" value="0.01" min="0" max="1.0" label="mscore_cutoff"/>
                    <param name="useUniquePeptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove peptides that are assigned for more than one proteins" help="We assume to use unique peptide for each protein"/>
                    <param name="fewMeasurements" type="select" label="Remove the features that have 1 or 2 measurements across runs" help="(fewMeasurements)">
                        <option value="remove" selected="true">remove</option>
                        <option value="keep">keep</option>
                    </param>
                    <param name="summaryforMultipleRows" type="select" label="Summary for MultipleRows" help="summaryforMultipleRows - when there are multiple measurements for certain feature and certain run, use highest or sum of all">
                        <option value="max" selected="true">max</option>
                        <option value="sum">sum</option>
                    </param>
                </section>
            </when>
            <when value="vignette">
                <param name="vignette_data" type="select" label="vignette data">
                    <option value="DDARawData">DDARawData</option>
                    <option value="DIARawData">DDARawData</option>
                </param>
            </when>
        </conditional>
        <section name="dp_options" title="dataProcess Options" expanded="false">
            <param name="logTrans" type="select" label="Log-transform Variable ABUNDANCE with base:" help="(logTrans)">
                <option value="2" selected="true">2</option>
                <option value="10">10</option>
            </param>
            <conditional name="norm">
                <param name="normalization" type="select" label="Normalization to remove systematic bias between MS runs">
                    <option value="equalizeMedians" selected="true">equalizeMedians - represents constant normalization</option>
                    <option value="quantile">quantile - quantile normalization</option>
                    <option value="globalStandards">globalStandards - normalization with global standards proteins</option>
                    <option value="FALSE">no normalization is performed</option>
                </param>
                <when value="equalizeMedians"/> 
                <when value="quantile"/> 
                <when value="globalStandards"> 
                    <param name="nameStandards" type="text" value="" label="global standard peptide names">
                        <help>peptide names should be double-quoted and separated by commas</help>
                        <validator type="empty_field" />
                        <validator type="regex" message="double-quoted names separated by commas"><![CDATA[^".+"(,".+")*$]]></validator>
                    </param>
                </when>
                <when value="FALSE"/> 
            </conditional>

            <param name="fillIncompleteRows" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Fill Incomplete Rows" help=" If the input dataset has incomplete rows, TRUE (default) adds the rows with intensity value=NA for missing peaks. FALSE reports error message with list of features which have incomplete rows"/>
            <conditional name="features">
                <param name="featureSubset" type="select" label="Features to use">
                    <option value="all" selected="true">Use all features that the data set has</option>
                    <option value="top3">Use the top 3 features which have highest average of log2(intensity) across runs</option>
                    <option value="topN">Use the top N features which have highest average of log2(intensity) across runs</option>
                    <option value="highQuality">Flag uninformative feature and outliers</option>
                </param>
                <when value="all"/>
                <when value="top3"/>
                <when value="topN">
                    <param name="n_top_feature" type="integer" value="3" min="1" label="The number of top features for featureSubset"/>
                </when>
                <when value="highQuality">
                    <param name="remove_uninformative_feature_outlier" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove features flagged with Uninformative feature_quality"/>
                </when>
            </conditional>
            <conditional name="summarize">
                <param name="summaryMethod" type="select" label="Summary Method">
                    <option value="TMP" selected="true">TMP - Tukey's median polish</option>
                    <option value="linear" selected="true">linear - linear mixed model</option>
                </param>
                <when value="TMP">
                    <param name="MBimpute" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Impute Missing Values 'NA' or '0' (depending on censoredInt option) by Accelated failure model" help="(MBimpute) TRUE - inserts 'NA' or '0' (depending on censoredInt option), . FALSE uses the values assigned by cutoffCensored"/> .
                    <param name="remove50missing" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove runs which have more than 50% missing values"/>
                </when>
                <when value="linear">
                    <param name="equalFeatureVar" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Account for heterogeneous variation among intensities from different features" help="(equalFeatureVar) TRUE assumes equal variance among intensities from features. FALSE means that we cannot assume equal variance among intensities from features, then we will account for heterogeneous variation from different features"/>
                </when>
            </conditional>
            <param name="censoredInt" type="select" label="Missing values to censor">
                <help>The output from Skyline and Progenesis should use '0'</help>
                <option value="NA" selected="true">Assume that all 'NA's in 'Intensity' column are censored</option>
                <option value="0">Use zero intensities '0' as censored intensity</option>
                <option value="NULL">Assume all NA intensites are randomly missing</option>
            </param>
            <param name="cutoffCensored" type="select" label="Cutoff value for censoring">
                <option value="minFeature" selected="true">minimum value for each feature</option>
                <option value="minRun">minimum value for each run</option>
                <option value="minFeatureNRun">smallest between minimum value of corresponding feature and minimum value of corresponding run</option>
            </param>
            <param name="maxQuantileforCensored" type="float" value="0.999" min="0.75" max="1.0" label="Maximum quantile for deciding censored missing values"/>
        </section>
        <param name="select_outputs" type="select" multiple="true" label="Select outputs">
            <option value="DDARawData">DDARawData</option>
        </param>
    </inputs>
    <outputs>
        <data name="log" format="txt" label="MSstats log"/>
        <data name="r_script" format="txt" label="MSstats Rscript"/>
        <data name="processed_data" format="tabular" label="MSstats ProcessedData" from_work_dir="ProcessedData.tsv"/>
        <data name="runlevel_data" format="tabular" label="MSstats RunlevelData" from_work_dir="RunlevelData.tsv"/>
        <data name="qcplot" format="pdf" label="MSstats QCPlot.pdf" from_work_dir="MSStats_only_QCPlot.pdf"/>
        <data name="profile_plot" format="pdf" label="MSstats ProfilePlot.pdf" from_work_dir="MSStats_only_ProfilePlot.pdf"/>
        <data name="profile_wsum_plot" format="pdf" label="MSstats ProfilePlot_wSummarization.pdf" from_work_dir="MSStats_only_ProfilePlot_wSummarization.pdf"/>
        <data name="condition_plot" format="pdf" label="MSstats ConditionPlot.pdf" from_work_dir="MSStats_only_ConditionPlot.pdf"/>
<!--
TODO: what files are:  "ModelQC" "PredictBySurvival"
PDF with visualizations: 
modelbasedQCplots: QQPlots: 1 pdf
modelbasedQCplots: ResidualPlots: 1 pdf
groupComparisonPlots: VolcanoPlot: 1 pdf
groupComparisonPlots: Heatmap: 1 pdf
groupComparisonPlots: ComparisonPlot: 1 pdf
Tabular file (from groupcomparison): "ComparisonResult"
Tabular file (from groupcomparison):  "ModelQC"
Tabular file (from groupcomparison): "fittedmodel"
Tabular file (from quantification): 1 tabular (or multiple if repeat will be allowed)
-->
    </outputs>
    <tests>
        <test>
            <conditional name="input">
                <param name="input_src" value="vignette"/>
                <param name="vignette_data" value="DDARawData"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="vignette"/>
                <param name="vignette_data" value="DDARawData"/>
            </conditional>
            <section name="dp_options">
                <conditional name="norm">
                    <param name="normalization" value="quantile"/>
                </conditional>
            </section>
            <output name="r_script">
                <assert_contents>
                    <has_text text="quantile" />
                </assert_contents>
            </output>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="MSstats"/>
                <param name="msstats_input" ftype="csv" value="msstats_testfile.txt"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="MSstats"/>
                <param name="msstats_input" ftype="tabular" value="msstats_testfile.tsv"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="MaxQuant"/>
                <param name="evidence" ftype="tabular" value="test_MQ_evidence.tabular"/>.
                <param name="annotation" ftype="tabular" value="test_MQ_annotation.txt"/>
                <param name="proteinGroups" ftype="tabular" value="test_MQ_proteingroups.tabular"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <!--
        <test>
            <conditional name="input">
                <param name="input_src" value="OpenMS"/>
                <param name="evidence" ftype="tabular" value=""/>.
                <param name="annotation" ftype="tabular" value=""/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>
        -->

        <test>
            <conditional name="input">
                <param name="input_src" value="OpenSWATH"/>
                <param name="evidence" ftype="tabular" value="test_swath_input_data.tabular"/>.
                <param name="annotation" ftype="tabular" value="test_swath_annotations.tabular"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

    </tests>
    <help><![CDATA[
        TODO: Fill in help.
    ]]></help>
    <citations>
        <citation type="doi">10.1093/bioinformatics/btu305</citation>
    </citations>
</tool>
