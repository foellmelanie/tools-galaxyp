<tool id="msstats" name="MSstats" version="@VERSION@.0" python_template_version="3.5">
    <description>statistical relative protein significance analysis in DDA, SRM and DIA Mass Spectrometry</description>
    <macros>
        <token name="@VERSION@">3.20.0</token>
        <xml name="useUniquePeptide">
            <param name="useUniquePeptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="remove peptides that are assigned for more than one proteins" help="We assume to use unique peptide for each protein"/>
        </xml>
        <xml name="summaryforMultipleRows">
            <param name="summaryforMultipleRows" type="select" label="Summary for MultipleRows" help="summaryforMultipleRows - when there are multiple measurements for certain feature and certain run, use highest or sum of all">
                <option value="max" selected="true">max</option>
                <option value="sum">sum</option>
            </param>
        </xml>
        <xml name="fewMeasurements">
            <param name="fewMeasurements" type="select" label="Remove the features that have 1 or 2 measurements across runs" help="(fewMeasurements)">
                <option value="remove" selected="true">remove</option>
                <option value="keep">keep</option>
            </param>
        </xml>
        <xml name="removeProtein_with1Peptide">
            <param name="removeProtein_with1Peptide" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove the proteins which have only 1 peptide and charge"/>
        </xml>
        
    </macros>
    <requirements>
        <requirement type="package" version="@VERSION@">bioconductor-msstats</requirement>
    </requirements>
    <command detect_errors="exit_code"><![CDATA[
        cat $msstats_script > '$r_script';
        Rscript $msstats_script
        && cat msstats.log > $log
    ]]></command>
    <configfiles>
        <configfile name="msstats_script"><![CDATA[
library('MSstats', warn.conflicts = F, quietly = T, verbose = F)

#if $input.input_src == 'MSstats'

  #if $input.msstats_input.is_of_type('csv')
raw <- read.csv("$input.msstats_input")
  #else
raw <- read.table("$input.msstats_input", sep="\t", header=TRUE)
  #end if

#elif $input.input_src == 'MaxQuant'
\# Read in MaxQuant files
input <- read.table("$input.evidence", sep="\t", header=TRUE)

proteinGroups <- read.table("$input.proteinGroups", sep="\t", header=TRUE)

\# Read in annotation including condition and biological replicates per run.
\# Users should make this annotation file. It is not the output from MaxQuant.
  #if $input.annotation.is_of_type('csv')
annot <- read.csv("$input.annotation", header=TRUE)
  #else
annot <- read.table("$input.annotation", sep="\t", header=TRUE)
  #end if

raw <- MaxQtoMSstatsFormat(evidence=input, 
                           annotation=annot, 
                           proteinGroups=proteinGroups,
                           useUniquePeptide=$input.input_options.useUniquePeptide, 
                           summaryforMultipleRows=$input.input_options.summaryforMultipleRows, 
                           fewMeasurements=$input.input_options.fewMeasurements, 
                           removeMpeptides=$input.input_options.removeMpeptides,
                           removeOxidationMpeptides=$input.input_options.removeOxidationMpeptides,
                           removeProtein_with1Peptide=$input.input_options.removeProtein_with1Peptide)

#elif $input.input_src == 'OpenMS'

  #if $input.evidence.is_of_type('csv')
input <- read.csv("$input.evidence", header=TRUE)
  #else
input <- read.table("$input.evidence", sep="\t", header=TRUE)
  #end if
  #if $input.annotation.is_of_type('csv')
annot <- read.csv("$input.annotation", header=TRUE)
  #else
annot <- read.table("$input.annotation", sep="\t", header=TRUE)
  #end if

raw <- OpenMStoMSstatsFormat(input,
                             annotation=annot,
                             useUniquePeptide=$input.input_options.useUniquePeptide, 
                             summaryforMultipleRows=$input.input_options.summaryforMultipleRows, 
                             fewMeasurements=$input.input_options.fewMeasurements, 
                             removeProtein_with1Peptide=$input.input_options.removeProtein_with1Peptide)

#elif $input.input_src == 'OpenSWATH'

  #if $input.evidence.is_of_type('csv')
input <- read.csv("$input.evidence", header=TRUE)
  #else
input <- read.table("$input.evidence", sep="\t", header=TRUE)
  #end if
  #if $input.annotation.is_of_type('csv')
annot <- read.csv("$input.annotation", header=TRUE)
  #else
annot <- read.table("$input.annotation", sep="\t", header=TRUE)
  #end if

raw <- OpenSWATHtoMSstatsFormat(input,
                                annotation=annot,
                                filter_with_mscore=$input.input_options.filter_with_mscore,
                                mscore_cutoff=$input.input_options.mscore_cutoff,
                                useUniquePeptide=$input.input_options.useUniquePeptide,
                                fewMeasurements="$input.input_options.fewMeasurements",
                                removeProtein_with1Feature=$input.input_options.removeProtein_with1Feature,
                                summaryforMultipleRows="$input.input_options.summaryforMultipleRows")

#elif $input.input_src == 'vignette'
raw <- $input.vignette_data
#end if

goldstandard.proposed <- dataProcess(raw,
                          logTrans=$dp_options.logTrans,
                          normalization="$dp_options.norm.normalization",
                          #if $dp_options.norm.normalization == 'globalStandards'
                          nameStandards=c($dp_options.norm.nameStandards),
                          #end if
                          ## address=$dp_options.address,
                          fillIncompleteRows=$dp_options.fillIncompleteRows,
                          featureSubset="$dp_options.features.featureSubset",
                          #if $dp_options.features.featureSubset == 'topN'
                          n_top_feature=$dp_options.features.n_top_feature,
                          #end if
                          #if $dp_options.features.featureSubset == 'highQuality'
                          remove_uninformative_feature_outlier=$dp_options.features.remove_uninformative_feature_outlier,
                          #end if
                          summaryMethod="$dp_options.summarize.summaryMethod",
                          #if $dp_options.summarize.summaryMethod == 'TMP'
                          MBimpute=$dp_options.summarize.MBimpute,
                          remove50missing=$dp_options.summarize.remove50missing,
                          #end if
                          #if $dp_options.summarize.summaryMethod == 'linear'
                          equalFeatureVar=$dp_options.summarize.equalFeatureVar,
                          #end if
                          #if $dp_options.censoredInt == 'NULL'
                          censoredInt=NULL,
                          #else
                          censoredInt="$dp_options.censoredInt",
                          #end if
                          cutoffCensored="$dp_options.cutoffCensored",
                          maxQuantileforCensored=$dp_options.maxQuantileforCensored,
                          clusters=NULL)
  
#if 'processed_data' in $selected_outputs
write.table(goldstandard.proposed\$ProcessedData, "ProcessedData.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
#end if
#if 'runlevel_data' in $selected_outputs
write.table(goldstandard.proposed\$RunlevelData, "RunlevelData.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
#end if

#if 'qcplot' in $selected_outputs
dataProcessPlots(data = goldstandard.proposed, type="QCplot", ylimUp=35,
                 width=5, height=5, address="MSStats_only_")
#end if

#if 'profile_plot' in $selected_outputs
dataProcessPlots(data = goldstandard.proposed, type="Profileplot",  ylimUp=35, featureName="NA", width=5, height=5, address="MSStats_only_")
#end if

#if 'profile_wsum_plot' in $selected_outputs
dataProcessPlots(data = goldstandard.proposed, type="Conditionplot", width=5, height=5, address="MSStats_only_")
#end if

## Quantifiaction
#if 'quant_sample_matrix' in $selected_outputs
sampleQuantMatrix <- quantification(goldstandard.proposed,  type="Sample")
write.table(sampleQuantMatrix, "SampleQuantificationMatrix.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
#end if

#if 'quant_sample_long' in $selected_outputs
sampleQuantLong <- quantification(goldstandard.proposed,  type="Sample", format="long")
write.table(sampleQuantLong, "SampleQuantificationLong.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
#end if

#if 'quant_group_matrix' in $selected_outputs
groupQuantMatrix <- quantification(goldstandard.proposed,  type="Group")
write.table(groupQuantMatrix, "GroupQuantificationMatrix.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
#end if

#if 'quant_group_long' in $selected_outputs
groupQuantLong <- quantification(goldstandard.proposed,  type="Group", format="long")
write.table(groupQuantLong, "GroupQuantificationLong.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
#end if

## Group Comparison
#if $group.group_comparison == 'yes'
\# Group Comparison
  #if $group.comparison_matrix.is_of_type('csv')
comp_matrix <- read.csv("$group.comparison_matrix", header=TRUE)
  #else
comp_matrix <- read.table("$group.comparison_matrix", sep="\t", header=TRUE)
  #end if

comparison = as.matrix(comp_matrix[,-1])
row.names(comparison) = as.character(comp_matrix[,1])
comparisons = groupComparison(contrast.matrix = comparison, data = goldstandard.proposed)

  #if 'comparison_result' in $group.select_outputs
write.table(comparisons\$ComparisonResult, "ComparisonResult.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
  #end if

  #if 'model_qc' in $group.select_outputs
write.table(comparisons\$ModelQC, "ModelQC.tsv", sep = "\t", quote = F, row.names = F, dec = ".")
  #end if

## TODO: transform fittedmodel to table 
##class(DDA2009.comparisons$fittedmodel) # list, probably good to output this somehow

## Visualizations:

  #if 'qqplot' in $group.select_outputs
\# normal quantile-quantile plots
modelBasedQCPlots(data=comparisons, type="QQPlots",
                  width=5, height=5, address="MSStats_group_")
  #end if

  #if 'residualplot' in $group.select_outputs
\# residual plots
modelBasedQCPlots(data=comparisons, type="ResidualPlots",
                  width=5, height=5, address="MSStats_group_")
  #end if

  #if 'volcanoplot' in $group.select_outputs
\# volcano plot
groupComparisonPlots(data = comparisons\$ComparisonResult, type = 'VolcanoPlot',
                     width=5, height=5, address="MSStats_group_")
  #end if

  #if 'heatmap' in $group.select_outputs
\# heatmap
groupComparisonPlots(data = comparisons\$ComparisonResult, type = 'Heatmap', address="MSStats_group_")
  #end if

  #if 'comparisonplot' in $group.select_outputs
\#comparison
groupComparisonPlots(data=comparisons\$ComparisonResult, type="ComparisonPlot",
                     width=5, height=5, address="MSStats_group_")
  #end if

#end if
        ]]></configfile>
    </configfiles>
    <inputs>
        <conditional name="input">
            <param name="input_src" type="select" label="input source">
                <option value="MSstats">MStats 10 column format</option>
                <option value="MaxQuant">MaxQuant</option>
                <option value="OpenMS">OpenMS</option>
                <option value="OpenSWATH">OpenSWATH</option>
                <option value="vignette">MSstats Vignette</option>
            </param>
            <when value="MSstats">
                <param name="msstats_input" type="data" format="tabular,csv" label="MSstats 10-column input"/>.
            </when>
            <when value="MaxQuant">
                <param name="evidence" type="data" format="tabular,csv" label="evidence.txt - feature-level data"/>.
                <param name="annotation" type="data" format="tabular,csv" label="annotation.txt data which includes Raw.file, Condition, BioReplicate, Run, IsotopeLabelType information"/>
                <param name="proteinGroups" type="data" format="tabular,csv" label="proteinGroups.txt" help="It needs to matching protein group ID. If proteinGroups=NULL, use 'Proteins' column in 'evidence.txt'"/>
                <param name="proteinID" type="select" label="Select Protein ID in proteinGroups.txt">
                    <option value="Proteins">Proteins</option>
                    <option value="proteinGroups">proteinGroups</option>
                </param>
                <section name="input_options" title="MaxQtoMSstatsFormat Options" expanded="false">
                    <expand macro="useUniquePeptide"/>
                    <expand macro="summaryforMultipleRows"/>
                    <expand macro="fewMeasurements"/>
                    <param name="removeMpeptides" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove the peptides including 'M' sequence"/>
                    <param name="removeOxidationMpeptides" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove the peptides including Oxidized 'M' sequence"/>
                    <expand macro="removeProtein_with1Peptide"/>
                </section>
            </when>
            <when value="OpenMS">
                <param name="evidence" type="data" format="tabular,csv" label="OpenSWATH_input"/>.
                <param name="annotation" type="data" format="tabular,csv" label="OpenSWATH_annotation"/>
                <section name="input_options" title="MaxQtoMSstatsFormat Options" expanded="false">
                    <expand macro="useUniquePeptide"/>
                    <expand macro="summaryforMultipleRows"/>
                    <expand macro="fewMeasurements"/>
                    <expand macro="removeProtein_with1Peptide"/>
                </section>
            </when>
            <when value="OpenSWATH">
                <param name="evidence" type="data" format="tabular,csv" label="OpenSWATH_input"/>.
                <param name="annotation" type="data" format="tabular,csv" label="OpenSWATH_annotation"/>
                <section name="input_options" title="MaxQtoMSstatsFormat Options" expanded="false">
                    <param name="filter_with_mscore" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Remove the peptides including 'M' sequence"/>
                    <param name="mscore_cutoff" type="float" value="0.01" min="0" max="1.0" label="mscore_cutoff"/>
                    <expand macro="useUniquePeptide"/>
                    <expand macro="fewMeasurements"/>
                    <expand macro="summaryforMultipleRows"/>
                </section>
            </when>
            <when value="vignette">
                <param name="vignette_data" type="select" label="vignette data">
                    <option value="DDARawData">DDARawData</option>
                    <option value="DIARawData">DDARawData</option>
                </param>
            </when>
        </conditional>
        <section name="dp_options" title="dataProcess Options" expanded="false">
            <param name="logTrans" type="select" label="Log-transform Variable ABUNDANCE with base:" help="(logTrans)">
                <option value="2" selected="true">2</option>
                <option value="10">10</option>
            </param>
            <conditional name="norm">
                <param name="normalization" type="select" label="Normalization to remove systematic bias between MS runs">
                    <option value="equalizeMedians" selected="true">equalizeMedians - represents constant normalization</option>
                    <option value="quantile">quantile - quantile normalization</option>
                    <option value="globalStandards">globalStandards - normalization with global standards proteins</option>
                    <option value="FALSE">no normalization is performed</option>
                </param>
                <when value="equalizeMedians"/> 
                <when value="quantile"/> 
                <when value="globalStandards"> 
                    <param name="nameStandards" type="text" value="" label="global standard peptide names">
                        <help>peptide names should be double-quoted and separated by commas</help>
                        <validator type="empty_field" />
                        <validator type="regex" message="double-quoted names separated by commas"><![CDATA[^".+"(,".+")*$]]></validator>
                    </param>
                </when>
                <when value="FALSE"/> 
            </conditional>
            <param name="fillIncompleteRows" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Fill Incomplete Rows" help=" If the input dataset has incomplete rows, TRUE (default) adds the rows with intensity value=NA for missing peaks. FALSE reports error message with list of features which have incomplete rows"/>
            <conditional name="features">
                <param name="featureSubset" type="select" label="Features to use">
                    <option value="all" selected="true">Use all features that the data set has</option>
                    <option value="top3">Use the top 3 features which have highest average of log2(intensity) across runs</option>
                    <option value="topN">Use the top N features which have highest average of log2(intensity) across runs</option>
                    <option value="highQuality">Flag uninformative feature and outliers</option>
                </param>
                <when value="all"/>
                <when value="top3"/>
                <when value="topN">
                    <param name="n_top_feature" type="integer" value="3" min="1" label="The number of top features for featureSubset"/>
                </when>
                <when value="highQuality">
                    <param name="remove_uninformative_feature_outlier" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove features flagged with Uninformative feature_quality"/>
                </when>
            </conditional>
            <conditional name="summarize">
                <param name="summaryMethod" type="select" label="Summary Method">
                    <option value="TMP" selected="true">TMP - Tukey's median polish</option>
                    <option value="linear" selected="true">linear - linear mixed model</option>
                </param>
                <when value="TMP">
                    <param name="MBimpute" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="true" label="Impute Missing Values 'NA' or '0' (depending on censoredInt option) by Accelated failure model" help="(MBimpute) TRUE - inserts 'NA' or '0' (depending on censoredInt option), . FALSE uses the values assigned by cutoffCensored"/> .
                    <param name="remove50missing" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Remove runs which have more than 50% missing values"/>
                </when>
                <when value="linear">
                    <param name="equalFeatureVar" type="boolean" truevalue="TRUE" falsevalue="FALSE" checked="false" label="Account for heterogeneous variation among intensities from different features" help="(equalFeatureVar) TRUE assumes equal variance among intensities from features. FALSE means that we cannot assume equal variance among intensities from features, then we will account for heterogeneous variation from different features"/>
                </when>
            </conditional>
            <param name="censoredInt" type="select" label="Missing values to censor">
                <help>The output from Skyline and Progenesis should use '0'</help>
                <option value="NA" selected="true">Assume that all 'NA's in 'Intensity' column are censored</option>
                <option value="0">Use zero intensities '0' as censored intensity</option>
                <option value="NULL">Assume all NA intensites are randomly missing</option>
            </param>
            <param name="cutoffCensored" type="select" label="Cutoff value for censoring">
                <option value="minFeature" selected="true">minimum value for each feature</option>
                <option value="minRun">minimum value for each run</option>
                <option value="minFeatureNRun">smallest between minimum value of corresponding feature and minimum value of corresponding run</option>
            </param>
            <param name="maxQuantileforCensored" type="float" value="0.999" min="0.75" max="1.0" label="Maximum quantile for deciding censored missing values"/>
        </section>
        <param name="selected_outputs" type="select" multiple="true" optional="false" label="Select outputs">
            <option value="log" selected="true">MSstats log</option>
            <option value="r_script" selected="true">MSstats Rscript</option>
            <option value="processed_data" selected="true">MSstats ProcessedData</option>
            <option value="runlevel_data" selected="true">MSstats RunlevelData</option>
            <option value="qcplot" selected="true">MSstats QCPlot.pdf</option>
            <option value="profile_plot" selected="true">MSstats ProfilePlot.pdf</option>
            <option value="profile_wsum_plot" selected="true">MSstats ProfilePlot_wSummarization.pdf</option>
            <option value="quant_sample_matrix" selected="true">Sample Quantification Matrix Table</option>
            <option value="quant_sample_long" selected="false">Sample Quantification Long Table</option>
            <option value="quant_group_matrix" selected="true">Group Quantification Matrix Table</option>
            <option value="quant_group_long" selected="false">Group Quantification Long Table</option>
        </param>

        <conditional name="group">
            <param name="group_comparison" type="select" label="Compare Groups">
                <option value="no">No</option>
                <option value="yes">Yes</option>
            </param>
            <when value="no"/>
            <when value="yes">
                <param name="comparison_matrix" type="data" format="tabular,csv" label="Comparison Matrix"/>.
                <param name="select_outputs" type="select" multiple="true" label="Select outputs">
                    <option value="comparison_result" selected="true">MSstats ComparisonResult.tsv</option>
                    <option value="model_qc" selected="true">MSstats ModelQC.tsv</option>
                    <option value="qqplot" selected="true">MSstats QQPlot.pdf</option>
                    <option value="residualplot" selected="true">MSstats ResidualPlot.pdf</option>
                    <option value="volcanoplot" selected="true">MSstats VolcanoPlot.pdf</option>
                    <option value="heatmap" selected="true">MSstats Heatmap.pdf</option>
                    <option value="comparisonplot" selected="true">MSstats ComparisonPlot.pdf</option>
                </param>
            </when>
        </conditional>
    </inputs>

    <outputs>
        <data name="log" format="txt" label="MSstats log">
            <filter>'log' in selected_outputs</filter>
        </data>
        <data name="r_script" format="txt" label="MSstats Rscript">
            <filter>'r_script' in selected_outputs</filter>
        </data>
        <data name="processed_data" format="tabular" label="MSstats ProcessedData" from_work_dir="ProcessedData.tsv">
            <filter>'processed_data' in selected_outputs</filter>
        </data>
        <data name="runlevel_data" format="tabular" label="MSstats RunlevelData" from_work_dir="RunlevelData.tsv">
            <filter>'runlevel_data' in selected_outputs</filter>
        </data>
        <data name="qcplot" format="pdf" label="MSstats QCPlot.pdf" from_work_dir="MSStats_only_QCPlot.pdf">
            <filter>'qcplot' in selected_outputs</filter>
        </data>
        <data name="profile_plot" format="pdf" label="MSstats ProfilePlot.pdf" from_work_dir="MSStats_only_ProfilePlot.pdf">
            <filter>'profile_plot' in selected_outputs</filter>
        </data>
        <data name="profile_wsum_plot" format="pdf" label="MSstats ProfilePlot_wSummarization.pdf" from_work_dir="MSStats_only_ProfilePlot_wSummarization.pdf">
            <filter>'profile_wsum_plot' in selected_outputs</filter>
        </data>
        <data name="condition_plot" format="pdf" label="MSstats ConditionPlot.pdf" from_work_dir="MSStats_only_ConditionPlot.pdf">
            <filter>'condition_plot' in selected_outputs</filter>
        </data>
        <data name="quant_sample_matrix" format="tabular" label="MSstats SampleQuantificationMatrix.tsv" from_work_dir="SampleQuantificationMatrix.tsv">
            <filter>'quant_sample_matrix' in selected_outputs</filter>
        </data>
        <data name="quant_sample_long" format="tabular" label="MSstats SampleQuantificationLong.tsv" from_work_dir="SampleQuantificationLong.tsv">
            <filter>'quant_sample_long' in selected_outputs</filter>
        </data>
        <data name="quant_group_matrix" format="tabular" label="MSstats GroupQuantificationMatrix.tsv" from_work_dir="GroupQuantificationMatrix.tsv">
            <filter>'quant_group_matrix' in selected_outputs</filter>
        </data>
        <data name="quant_group_long" format="tabular" label="MSstats GroupQuantificationLong.tsv" from_work_dir="GroupQuantificationLong.tsv">
            <filter>'quant_group_long' in selected_outputs</filter>
        </data>
        <data name="comparison_result" format="tabular" label="MSstats ComparisonResult.tsv" from_work_dir="ComparisonResult.tsv">
            <filter> group['group_comparison'] == 'yes' and 'comparison_result' in group['select_outputs']</filter>
        </data>
        <data name="model_qc" format="tabular" label="MSstats ModelQC.tsv" from_work_dir="ModelQC.tsv">
            <filter> group['group_comparison'] == 'yes' and 'model_qc' in group['select_outputs']</filter>
        </data>
        <data name="qqplot" format="pdf" label="MSstats ModelQQ.pdf" from_work_dir="MSStats_group_QQPlot.pdf">
            <filter> group['group_comparison'] == 'yes' and 'qqplot' in group['select_outputs']</filter>
        </data>
        <data name="residualplot" format="pdf" label="MSstats ResidualPlot.pdf" from_work_dir="MSStats_group_ResidualPlot.pdf">
            <filter> group['group_comparison'] == 'yes' and 'residualplot' in group['select_outputs']</filter>
        </data>
        <data name="volcanoplot" format="pdf" label="MSstats VolcanoPlot.pdf" from_work_dir="MSStats_group_VolcanoPlot.pdf">
            <filter> group['group_comparison'] == 'yes' and 'volcanoplot' in group['select_outputs']</filter>
        </data>
        <data name="heatmap" format="pdf" label="MSstats Heatmap.pdf" from_work_dir="MSStats_group_Heatmap.pdf">
            <filter> group['group_comparison'] == 'yes' and 'heatmap' in group['select_outputs']</filter>
        </data>
        <data name="comparisonplot" format="pdf" label="MSstats ComparisonPlot.pdf" from_work_dir="MSStats_group_ComparisonPlot.pdf">
            <filter> group['group_comparison'] == 'yes' and 'comparisonplot' in group['select_outputs']</filter>
        </data>
<!--
Tabular file (from groupcomparison): "fittedmodel"
-->
    </outputs>
    <tests>
        <test>
            <conditional name="input">
                <param name="input_src" value="vignette"/>
                <param name="vignette_data" value="DDARawData"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="vignette"/>
                <param name="vignette_data" value="DDARawData"/>
            </conditional>
            <section name="dp_options">
                <conditional name="norm">
                    <param name="normalization" value="quantile"/>
                </conditional>
            </section>
            <output name="r_script">
                <assert_contents>
                    <has_text text="quantile" />
                </assert_contents>
            </output>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="MSstats"/>
                <param name="msstats_input" ftype="csv" value="msstats_testfile.txt"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="MSstats"/>
                <param name="msstats_input" ftype="tabular" value="msstats_testfile.tsv"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <test>
            <conditional name="input">
                <param name="input_src" value="MaxQuant"/>
                <param name="evidence" ftype="tabular" value="test_MQ_evidence.tabular"/>.
                <param name="annotation" ftype="tabular" value="test_MQ_annotation.txt"/>
                <param name="proteinGroups" ftype="tabular" value="test_MQ_proteingroups.tabular"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

        <!--
        <test>
            <conditional name="input">
                <param name="input_src" value="OpenMS"/>
                <param name="evidence" ftype="tabular" value=""/>.
                <param name="annotation" ftype="tabular" value=""/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>
        -->

        <test>
            <conditional name="input">
                <param name="input_src" value="OpenSWATH"/>
                <param name="evidence" ftype="tabular" value="test_swath_input_data.tabular"/>.
                <param name="annotation" ftype="tabular" value="test_swath_annotations.tabular"/>
            </conditional>
            <output name="processed_data">
                <assert_contents>
                    <has_text text="D.GPLTGTYR" />
                </assert_contents>
            </output>
        </test>

    </tests>
    <help><![CDATA[
**MSstats**


**MaxQuant input**: 

::

  * Contaminants (and reverse and only ID by site) from MaxQuant tool are automatically removed; ! if you use human samples such as blood or skin, it might be better to not use contaminants in Maxquant to prevent removal of albumin/keratins
  * Dataprocess needs special parameters, e.g. censoredInt="NA", ## !! important for MaxQuant page 39 of manual


**OpenSwath**: 

::

  * In dataProcess, users need to use censoredInt='0' for OpenSWATH output.


**Structure of Annotation File (input)** datamash on output file helps to get the different file names; cut this column and fill in annotation information. 


**Structure of contrast matrix (input)**
Imputation options for summarization TMP: page 19, which combination does what and which combinations are not valid


    ]]></help>
    <citations>
        <citation type="doi">10.1093/bioinformatics/btu305</citation>
    </citations>
</tool>
